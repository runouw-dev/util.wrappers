if(!project.hasProperty('artifactoryUser') || !project.hasProperty('artifactoryPassword')) {
    System.err.println 'artifactoryUser or artifactoryPassword is not defined! artifactoryPublish will be disabled.'   
} else {
    artifactory {
        contextUrl = 'http://jartifacts.longlinkislong.com/artifactory'
        publish {
            repository {
                if (build == 'snapshot') {
                    repoKey = 'libs-snapshot-local'
                } else if (build == 'release') {
                    repoKey = 'libs-release-local'
                } else {
                    throw new IllegalStateException("Invalid build type: $build")
                }
                
                username = "${artifactoryUser}"
                password = "${artifactoryPassword}"                
            }
            defaults {
                publications ('mavenJava')
            }
        }    
    }
}

task packageJavadoc(type: Jar, dependsOn: 'javadoc') {
    from javadoc.destinationDir
    classifier = 'javadoc'
}

task packageSources(type: Jar, dependsOn: 'classes') {
    from sourceSets.main.allSource
    classifier = 'sources'
}
 
publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            
            artifact(packageSources)
            artifact(packageJavadoc)
            
            groupId = "${group}"
            
            // get version number for outputting to artifactory
            if (build == 'snapshot') {
                version = "${getRelease(project.name)}#${getHash()}-SNAPSHOT"          
            } else if (build == 'release') {
                version = getRelease(project.name)
            } else {
                throw new IllegalStateException("Unsupported build type: $build")
            }
        }    
    }
}

task versionIncrementBuild << {
    def rawVersion = getRelease(project.name)
    
    if (rawVersion == null) {        
        setVersion(0, 0, 0)
    } else {        
        def version = rawVersion.split('\\.')  
        def major = version[0].toInteger()
        def minor = version[1].toInteger()
        def revision = version[2].toInteger()   
        
        setVersion(major, minor, revision + 1)               
        
        println "Version changed: $rawVersion -> $major.$minor.${revision + 1}"
    }    
}

task versionIncrementMajor << {
    def rawVersion = getRelease(project.name)
    
    if (rawVersion == null) {
        setVersion(1, 0, 0)
    } else {
        def version = rawVersion.split('\\.')  
        def major = version[0].toInteger()          
        
        setVersion(major + 1, 0, 0)               
        
        println "Version changed: $rawVersion -> ${major+1}.0.0"
    }
}

task versionIncrementMinor << {
    def rawVersion = getRelease(project.name)
    
    if (rawVersion == null) {
        setVersion(1, 0, 0)
    } else {
        def version = rawVersion.split('\\.')  
        def major = version[0].toInteger()
        def minor = version[1].toInteger()
        
        setVersion(major, minor + 1, 0)              
        
        println "Version changed: $rawVersion -> $major.${minor + 1}.0"
    }
}

def setVersion(major, minor, revision) {    
    def process = new ProcessBuilder('sqlite3', database, "REPLACE INTO versioning (library, hash, major, minor, revision) VALUES ('$project.name', '${getHash()}', $major, $minor, $revision)").redirectErrorStream(true).start()

    process.inputStream.eachLine { println it }
    
    println "Set version to $major.$minor.$revision"
}

def getHash() {
    'git rev-parse --short HEAD'.execute(null, projectDir).text.trim()
}

def getSnapshot(projectName) {    
    if (isJenkins.toBoolean()) {
        def hash = new ProcessBuilder('sqlite3', database, "SELECT hash FROM versioning WHERE library='$projectName'").start().text.trim()
        
        return "${getRelease(projectName)}#$hash-SNAPSHOT"
    } else {
        return "http://jenkins.longlinkislong.com/job/$projectName/lastSuccessfulBuild/artifact/build/version.snapshot".toURL().text.trim()
    }
}


def getVersion(projectName, buildType) {
    if (buildType == 'snapshot') {
        return getSnapshot(projectName)
    } else {
        return getRelease(projectName)
    }
}

def getRelease(projectName) {
    if (isJenkins.toBoolean()) {
        def version = new ProcessBuilder('sqlite3', database, "SELECT major,minor,revision FROM versioning WHERE library='$projectName'").start().text.trim()

        if (version.empty) {
            def dbFile = new File(database).absolutePath
            System.err.println("Library [$projectName] was not found in database: $dbFile")
            return null
        } else {
            return version.replace('|', '.')
        }
    } else {
        "http://jenkins.longlinkislong.com/job/$projectName/lastSuccessfulBuild/artifact/build/version.release".toURL().text.trim()
    }
}

// methods to expose to build.gradle
gradle.allprojects{
    ext.getVersion = {projectName ->
        return getVersion(projectName, build)
    }
}

task version << {
    println getVersion(project.name, build)
}

task versionRelease << {    
    def version = getRelease(project.name)
    
    if (version == null) {        
        setVersion(0, 0, 0)
        println "Version initialized to 0.0.0"
    } else {
        println "Current version: $version"
    }
}

task versionSnapshot << {
    println getSnapshot(project.name)
}

task versionDump << {
    if (isJenkins.toBoolean()) {
        println 'I am Jenkins'
    }
    
    def snapshot = new File("$projectDir/build/version.snapshot")
    def release = new File("$projectDir/build/version.release")
    
    def revHash = getHash()
    def snapshotVersion = "$revHash-SNAPSHOT"
    def releaseVersion = getRelease(project.name)
                                                
    if (releaseVersion == null) {
        setVersion(0, 0, 0)
        releaseVersion = '0.0.0'
    } else {
        def process = new ProcessBuilder('sqlite3', database, "UPDATE versioning SET hash='$revHash' WHERE library='$project.name'").redirectErrorStream(true).start()
        
        process.inputStream.eachLine { println it }
    }
                                                
    snapshot.write snapshotVersion
    release.write releaseVersion
}

